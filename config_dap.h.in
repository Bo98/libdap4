/* config.h.in.  Generated automatically from configure.in by autoheader.  */
#ifndef _DODS_CONFIG_H_
#define _DODS_CONFIG_H_

/* $Log: config_dap.h.in,v $
/* Revision 1.17  1996/10/01 16:27:38  jimg
/* Changed XDR_SHORT to XDR_INT16 and XDR_USHORT to XDR_UINT16 (to match the
/* Int16 and UInt16 classes).
/*
 * Revision 1.16  1996/08/26 21:13:03  jimg
 * Changes for version 2.07
 *
 * Revision 1.15  1996/08/13 18:42:48  jimg
 * Added __unused__ macro.
 *
 * Revision 1.14  1996/07/08 23:19:49  jimg
 * Added HAVE_EXPECT compile-time variable.
 *
 * Revision 1.13  1996/06/20 15:54:29  jimg
 * Added HAVE_SEM_UNION for hosts that do not define the union semun {} union.
 * Changed SEM_PROTO to HAVE_SEM_PROTO to be more inline with other similar
 * defines.
 *
 * Revision 1.12  1996/06/18 21:33:01  jimg
 * Added define SEM_PROTO which is used to control inclusion of the semaphore
 * prototypes in Connect.cc.
 * Removed GZIP define and replaced it with a DODS_ROOT define (which is the
 * double quoted path to the DODS root directory of the build).
 *
 * Revision 1.11  1996/06/07 05:07:29  jimg
 * Added GZIP define.
 *
 * Revision 1.10  1996/06/05 20:42:12  jimg
 * Moved symbols from config_netio.h.in to this file.
 *
 * Revision 1.9  1996/05/14 15:38:49  jimg
 * These changes have already been checked in once before. However, I
 * corrupted the source repository and restored it from a 5/9/96 backup
 * tape. The previous version's log entry should cover the changes.
 *
 * Revision 1.8  1996/04/05 21:59:32  jimg
 * Misc Changes for release 2.0.1 of the core software - for developers.
 *
 * Revision 1.7  1996/04/05 16:59:24  jimg
 * Re: XDR_INT and XDR_FLOAT; Moved cast of xdr_int, long, float and double
 * from here to the places where the functions are passed as parameters. This
 * fixes the bug that the return values of these functions were being cast to
 * an incompatible type where they were used.
 *
 * Revision 1.6  1996/04/04 18:03:55  jimg
 * Fixed comment headers.
 *
 * Revision 1.5  1995/06/28  17:13:28  dan
 * Modifed XDR_type definitions to explicitly cast to (xdrproc_t),
 * resolving problem associated with <rpc/xdr.h> in OSF 3.X.
 *
 * Revision 1.4  1995/02/10  02:38:32  jimg
 * Added DBMALLOC to set of flags defined with configure is given the
 * --enable-dbnew switch.
 *
 * Revision 1.3  1994/12/09  21:43:54  jimg
 * Added Dan's XDR_INT hack to acconfig.h - modified slightly and duplicated
 * for floats.
 *
 * Revision 1.2  1994/12/07  21:15:09  jimg
 * Updated files to work with autoconf 2.1.
 * 
 */

/* Wrap the defines in this section with HAVE_CONFIG_H so that
   libraries/servers that define these symbols on the command line won't
   redefine them when/if this file is included in their code. */

#ifdef HAVE_CONFIG_H

/* Define if using alloca.c.  */
#undef C_ALLOCA

/* Define to empty if the keyword does not work.  */
#undef const

/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
   This function is required for alloca.c support on those systems.  */
#undef CRAY_STACKSEG_END

/* Define if you have alloca, as a function or macro.  */
#undef HAVE_ALLOCA

/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */
#undef HAVE_ALLOCA_H

/* Define as __inline if that's what the C compiler calls it.  */
#undef inline

/* If using the C implementation of alloca, define if you know the
   direction of stack growth for your system; otherwise it will be
   automatically deduced at run-time.
	STACK_DIRECTION > 0 => grows toward higher addresses
	STACK_DIRECTION < 0 => grows toward lower addresses
	STACK_DIRECTION = 0 => direction of growth unknown
 */
#undef STACK_DIRECTION

/* Define if you have the ANSI C header files.  */
#undef STDC_HEADERS

/* Define if your <sys/time.h> declares struct tm.  */
#undef TM_IN_SYS_TIME

/* Client application name */
#undef CNAME

/* Client Application version */
#undef CVER

/* DODS Version */
#undef DVR

/* If defined, enable memory leak detection through libdbnew.a. Make sure to */
/* link with that library. */
#undef TRACE_NEW

/* If defined, enable memory leak detection through libdbmalloc.a. Nominally */
/* not necessary with c++, but useful with the DODS library because it (and  */
/* xdr) make use of malloc/free. */
#undef DBMALLOC

/* If defined, the DBG() macro defined in debug.h is activated. This macro */
/* is used for nominal program instrumentation */
#undef DEBUG

/* If defined, the DBG2() macro defined in debug.h is activated. This macro */
/* is used for detailed program instrumentation. Anything that prints half a */
/* page or more of stuff every time it is executed should be inside DBG2(), */
/* not DBG(). */
#undef DEBUG2

/* The number of bytes in a char.  */
#undef SIZEOF_CHAR

/* The number of bytes in a double.  */
#undef SIZEOF_DOUBLE

/* The number of bytes in a float.  */
#undef SIZEOF_FLOAT

/* The number of bytes in a int.  */
#undef SIZEOF_INT

/* The number of bytes in a long.  */
#undef SIZEOF_LONG

/* Define as 1 if you have the expect library (which requries tcl) */
#undef HAVE_EXPECT

/* Define if you have the strdup function.  */
#undef HAVE_STRDUP

/* Define if you have the <fcntl.h> header file.  */
#undef HAVE_FCNTL_H

/* Define if you have the <limits.h> header file.  */
#undef HAVE_LIMITS_H

/* Define if you have the <unistd.h> header file.  */
#undef HAVE_UNISTD_H

/* Where is DODS_ROOT? This can be changed at runtime by an environment
   variable. */
#undef DODS_ROOT

/* Does <sys/sem.h> contain prototypes for semctl(), ... ? */
#undef HAVE_SEM_PROTO

/* Does <sys/sem.h> contain the definition of union semun {}? */
#undef HAVE_SEM_UNION

#endif /* HAVE_CONFIG_H */

/* GNU gcc/g++ provides a way to mark variables, etc. as unused */

#if defined(__GNUG__) || defined(__GNUC__)
#define __unused__ __attribute__ ((unused))
#else
#define __unused__ 
#endif

/*
  Determine at compile-time the sizes of various datatypes. This uses symbols
  defined by configure (See configure.in).
  jhrg 10/24/94
*/

#ifndef __DODS_DATATYPES__
#define __DODS_DATATYPES__

#if SIZEOF_LONG == 4
typedef long dods_int32;
typedef unsigned long dods_uint32;
#define XDR_INT32 xdr_long
#define XDR_UINT32 xdr_u_long
#elif SIZEOF_INT == 4
typedef int dods_int32;
typedef unsigned int dods_uint32;
#define XDR_INT32 xdr_int
#define XDR_UINT32 xdr_u_int
#else
#error "How do I get a 32 bit integer on this machine?"
#endif

/* Assume short is 16 bits... */
typedef short dods_int16;
typedef unsigned short dods_uint16;
#define XDR_INT16 xdr_short
#define XDR_UINT16 xdr_u_short

#if SIZEOF_CHAR == 1
typedef unsigned char dods_byte;
#else
#error "How do I get an 8 bit unsigned integer on this machine?"
#endif

#if SIZEOF_DOUBLE == 8
typedef double dods_float64;
typedef float dods_float32;		
#define XDR_FLOAT64 xdr_double
#define XDR_FLOAT32 xdr_float
#elif SIZEOF_FLOAT == 8		/* yea, I never heard of this either... */
typedef float dods_float64;		
typedef float dods_float32;		
#define XDR_FLOAT64 xdr_float
#define XDR_FLOAT32 xdr_float
#else
#error "How do I get a 64 bit floating point type on this machine?"
#endif

#endif /* __DODS_DATATYPES__ */

#endif /* _DODS_CONFIG_H_ */


