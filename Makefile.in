
# $Id: Makefile.in,v 1.69 1998/02/05 20:13:55 jimg Exp $

@SET_MAKE@

# Set makefile variables, some with values supplied by configure 
# DEFS gets the `-D' defines that describe what a particular system has
# or doesn't have.

# The library libdap++.a contains the code for the generation of the DAS and
# DDS structures plus the code for data transmission and the GNU libg++.a
# classes Map, Stack, Plex and Vec.
# geturl is a simple program that uses the dap++ library plus others to fetch
# a url. In addition it can read and process DAS and DDS objects, displaying
# the print representation on the screen.

PROG = libdap++.a geturl usage
DODS_ROOT = ../..

WWW_ROOT = @WWW_ROOT@
INCS = -I. -IMap -IStack -IPlex -IVec @INCS@
DEFS = @DEFS@ -DUSE_LIBGXX_INLINES
CPPFLAGS = @CPPFLAGS@ $(DEFS) $(INCS)
CXXFLAGS = @CXXFLAGS@ -Wall -fno-rtti -fno-exceptions
LDFLAGS = @LDFLAGS@ -L. -L$(DODS_ROOT)/lib
LFLAGS = -8
YFLAGS = -d -v
LIBS = -ldap++ @LIBS@
TAGS_FLAGS = -b

# Set the instalation directories; prefix can be set on the command line
# during Makefile construction with `./configure --prefix /my/choice'

prefix = @prefix@
exec_prefix = $(prefix)
bindir = $(exec_prefix)/bin
libdir = $(exec_prefix)/lib
includedir = $(prefix)/include
manext = 1
mandir = $(prefix)/man/man$(manext)

src = $(DODS_ROOT)/src
etcdir = $(DODS_ROOT)/etc

INSTALLMAN = man

SHELL = /bin/sh
srcdir = @srcdir@
# VPATH = @srcdir@:Map:Stack:Plex:Vec
dir = @dir@

# testsuite specifics
RUNTEST = runtest
RUNTESTFLAGS = #--all --verbose

# names of key programs

LN_S = @LN_S@
CP = cp
AWK = @AWK@
CC = @CC@
CXX = @CXX@
YACC = @YACC@
LEX = @LEX@
AR = ar
TAGS = etags
RANLIB = @RANLIB@
INSTALL = @INSTALL@
INSTALL_DATA = @INSTALL_DATA@
INSTALL_PROGRAM = @INSTALL_PROGRAM@
STRIP = strip

NETIOSRCS = Connect.cc Connections.cc cgi_util.cc escaping.cc Gui.cc \
	    DODSFilter.cc
NETIOOBJS = Connect.o Connections.o cgi_util.o escaping.o Gui.o DODSFilter.o
NETIOHDRS = Connect.h Connections.h Connections.cc cgi_util.h Gui.h \
	    DODSFilter.h

DAS_GRAM_OBJS = lex.das.o das.tab.o parser-util.o
DDS_GRAM_OBJS = lex.dds.o dds.tab.o parser-util.o
EXPR_GRAM_OBJS = lex.expr.o expr.tab.o expr.o
ERROR_GRAM_OBJS = lex.Error.o Error.tab.o

DASHDRS = AttrTable.h DAS.h 
DASSRCS = AttrTable.cc DAS.cc
DASOBJS = AttrTable.o DAS.o $(DAS_GRAM_OBJS)

DDSHDRS = DDS.h DataDDS.h
DDSSRCS = DDS.cc DataDDS.cc
DDSOBJS = DDS.o DataDDS.o $(TYPEOBJS) $(DDS_GRAM_OBJS) $(EXPR_GRAM_OBJS)

EXPRHDRS = expr.h Clause.h
EXPRSRCS = expr.cc Clause.cc
EXPROBJS = expr.o Clause.o $(TYPEOBJS) $(EXPR_GRAM_OBJS)

ERRORHDRS = Error.h
ERROROBJS = Error.o $(ERROR_GRAM_OBJS)
ERRORSRCS = Error.cc

TYPEHDRS = BaseType.h Byte.h Int32.h \
	   Float64.h Str.h Url.h Vector.h List.h Array.h Structure.h \
	   Sequence.h Function.h Grid.h UInt32.h util.h
# Int16.h Uint16.h Float32.h

TYPESRCS = BaseType.cc Byte.cc Int32.cc Float64.cc Str.cc Url.cc \
	   Vector.cc List.cc Array.cc Structure.cc Sequence.cc Function.cc \
	   Grid.cc UInt32.cc util.cc
# Int16.cc Uint16.cc Float32.cc 

TYPEOBJS = BaseType.o Byte.o Int32.o Float64.o Str.o Url.o \
	   Vector.o List.o Array.o Structure.o Sequence.o Function.o Grid.o \
           UInt32.o  util.o
# Int16.o Uint16.o Float32.o

# These object files are built using source code generated from the GNU
# libg++ source with `genclass'. They are part of the the DAP library.

GNUOBJS = Vec/BaseTypeVec.o Plex/String.Plex.o Plex/String.XPlex.o \
	  Stack/BTPlex.o Stack/BTStack.o Stack/BTXPStack.o Stack/BTXPlex.o \
	  Map/AttrMap.o Map/AttrVHMap.o Map/DASMap.o Map/DASVHMap.o

GNUHDRS = Map/AttrMap.h        Plex/String.Plex.h   Stack/BTXPlex.h \
	  Map/AttrVHMap.h      Plex/String.XPlex.h  Stack/BTdefs.h \
	  Map/Attrdefs.h       Plex/String.defs.h   Vec/BaseTypeVec.h \
	  Map/DASMap.h         Stack/BTPlex.h       Vec/BaseTypedefs.h \
	  Map/DASVHMap.h       Stack/BTStack.h	    Map/DASdefs.h \
	  Stack/BTXPStack.h

TESTSRCS = TestByte.cc TestInt32.cc TestFloat64.cc TestStr.cc TestUrl.cc \
	   TestArray.cc TestStructure.cc TestList.cc TestSequence.cc \
	   TestFunction.cc TestGrid.cc TestUInt32.cc

TESTOBJS = TestByte.o TestInt32.o TestFloat64.o TestStr.o TestUrl.o \
	   TestArray.o TestStructure.o TestList.o TestSequence.o \
	   TestFunction.o TestGrid.o TestUInt32.o

TESTPROGSRCS = das-test.cc dds-test.cc expr-test.cc error-test.cc geturl.cc

all: grammars $(PROG)

libdap++.a: $(DASOBJS) $(DDSOBJS) $(TYPEOBJS) $(GNUOBJS) $(ERROROBJS)\
	    $(EXPROBJS) $(NETIOOBJS)
	    $(AR) cru $@ $?
	    $(RANLIB) $@

# geturl is really a test driver, but it is so useful in other contexts that
# I have decided to build it as part of the `all' target. jhrg 7/11/96

geturl: libdap++.a $(TESTOBJS) geturl.o
	$(CXX) $(LDFLAGS) -o geturl geturl.o $(TESTOBJS) $(LIBS)

# The program named usage is the filter that is run by the CGI dispatch
# script as the `usage server'. This filter is the same for all different
# server types so it does not need to be specialized for each API.

usage: libdap++.a $(TESTOBJS) usage.o
	$(CXX) $(LDFLAGS) -o usage usage.o $(TESTOBJS) $(LIBS)

# Build the test drivers

test-drivers: das-test dds-test expr-test error-test cgi-util-test www-test

das-test: libdap++.a $(TESTOBJS) das-test.o das.tab.h
	$(CXX) $(LDFLAGS) -o das-test $(TESTOBJS) das-test.o $(LIBS)

dds-test: libdap++.a $(TESTOBJS) dds-test.o dds.tab.h
	$(CXX) $(LDFLAGS) -o dds-test $(TESTOBJS) dds-test.o $(LIBS)

# trans-test: libdap++.a $(TESTOBJS) trans-test.o
#	$(CXX) $(LDFLAGS) -o trans-test $(TESTOBJS) trans-test.o $(LIBS)

expr-test: libdap++.a $(TESTOBJS) expr-test.o expr.tab.h
	$(CXX) $(LDFLAGS) -o expr-test $(TESTOBJS) expr-test.o \
	       $(LIBS)

error-test: error-test.o Error.tab.h $(ERROROBJS) $(TESTOBJS)
	$(CXX) $(LDFLAGS) -o error-test error-test.o $(ERROROBJS) $(TESTOBJS) \
	$(LIBS)

cgi-util-test: libdap++.a cgi_util.o $(TESTOBJS)
	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -DTEST_CGI_UTIL -c cgi_util.cc
	$(CXX) $(LDFLAGS) -o cgi-util-test cgi_util.o $(TESTOBJS) $(LIBS)
	-rm -f cgi_util.o

www-test: www-test.o
	$(CC) $(LDFLAGS) -o www-test www-test.o -lwww

# The grammar targets.

grammars: lex.das.c das.tab.h lex.dds.c dds.tab.h lex.expr.c expr.tab.h \
		lex.Error.c Error.tab.h

# Build the DAS scanner (a C source module compiled with C++)

lex.das.c: das.lex das.tab.c das.tab.h
	$(LEX) $(LFLAGS) -Pdas das.lex

lex.das.o: lex.das.c
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) -c lex.das.c -o lex.das.o

# Build the DAS parser
# Note that awk is used to add a param to dasparse().

das.tab.c das.tab.h: das.y DAS.h munge-bison.awk
	$(YACC) $(YFLAGS) -p das das.y
	$(AWK) -f munge-bison.awk das.tab.c > tmp
	mv tmp das.tab.c

das.tab.o: das.tab.c		# build using C++ compiler
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) -c das.tab.c -o das.tab.o

# Build the DDS Scanner.

lex.dds.c: dds.lex dds.tab.c dds.tab.h
	$(LEX) $(LFLAGS) -Pdds dds.lex

lex.dds.o: lex.dds.c
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) -c lex.dds.c -o lex.dds.o

# Build the DDS parser

dds.tab.c dds.tab.h: dds.y munge-bison.awk
	$(YACC) $(YFLAGS) -p dds dds.y
	$(AWK) -f munge-bison.awk dds.tab.c > tmp
	mv tmp dds.tab.c

dds.tab.o: dds.tab.c		# build using C++ compiler
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) -c dds.tab.c -o dds.tab.o

# Build the CE Scanner.

lex.expr.c: expr.lex expr.tab.c expr.tab.h
	$(LEX) $(LFLAGS) -Pexpr expr.lex

lex.expr.o: lex.expr.c
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) -c lex.expr.c -o lex.expr.o

# Build the CE parser

expr.tab.c expr.tab.h: expr.y munge-bison.awk
	$(YACC) $(YFLAGS) -p expr expr.y
	$(AWK) -f munge-bison.awk expr.tab.c > tmp
	mv tmp expr.tab.c

expr.tab.o: expr.tab.c		# build using C++ compiler
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) -c expr.tab.c -o expr.tab.o

# Build the Error object scanner.

lex.Error.c: Error.lex Error.tab.c Error.tab.h
	$(LEX) $(LFLAGS) -PError Error.lex

lex.Error.o: lex.Error.c
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) -c lex.Error.c -o lex.Error.o

# Build the Error object parser.

Error.tab.c Error.tab.h: Error.y munge-bison.awk
	$(YACC) $(YFLAGS) -p Error Error.y
	$(AWK) -f munge-bison.awk Error.tab.c > tmp
	mv tmp Error.tab.c

Error.tab.o: Error.tab.c	# build using C++ compiler
	$(CXX) $(CXXFLAGS) $(CPPFLAGS) -c Error.tab.c -o Error.tab.o

# Standard targets with some customization for das-test and dds-test

install: all install-headers install-geturl install-gui install-usage
	$(INSTALL_DATA) DODS_Dispatch.pm $(etcdir)
	$(INSTALL_DATA) libdap++.a $(libdir)
	$(RANLIB) $(libdir)/libdap++.a

install-headers:
	$(INSTALL_DATA) config_dap.h $(includedir)
	$(INSTALL_DATA) debug.h $(includedir)
	$(INSTALL_DATA) dods-limits.h $(includedir)
	for h in $(ERRORHDRS) $(EXPRHDRS) $(TYPEHDRS) $(DDSHDRS) $(DASHDRS) \
		 $(GNUHDRS) $(NETIOHDRS); \
	    do $(INSTALL_DATA) $$h $(includedir); done

install-geturl: geturl
	$(INSTALL_PROGRAM) -s geturl $(bindir)

install-gui:
	for tcl_prog in dods_gui.tcl error.tcl progress.tcl; \
	    do $(INSTALL_PROGRAM) $$tcl_prog $(etcdir); done

install-usage: usage
	$(INSTALL_PROGRAM) -s usage $(etcdir)

Makefile: ${srcdir}/Makefile.in
	${SHELL} ./config.status

check: libdap++.a das-check dds-check expr-check

# These tests all fail when linking with -lnew_debug.

das-check: das-test
	-rootme=`pwd` && export rootme && \
	${RUNTEST} ${RUNTESTFLAGS} --tool das-test --srcdir das-testsuite

dds-check: dds-test
	-rootme=`pwd` && export rootme && \
	${RUNTEST} ${RUNTESTFLAGS} --tool dds-test --srcdir dds-testsuite

expr-check: expr-test
	-rootme=`pwd` && export rootme && \
	${RUNTEST} ${RUNTESTFLAGS} --tool expr-test --srcdir expr-testsuite

error-check: error-test
	echo "No tests for the Error object"

# This tests the servers assuming that DODS has been installed on dcz, dods
# and rhody. It also assumes that the cgi bin directory `test' points to the
# place where the new servers are installed. On all of these machines there
# is a symbolic link `DODS-test' that should be linked to the top-level
# directory of the version to test *and* each machine's httpd.conf should
# list as a ScriptAlias .../DODS-test/etc. jhrg 12/30/97.

server-check: geturl
	-rootme=`pwd` && export rootme && \
	${RUNTEST} ${RUNTESTFLAGS} --tool geturl --srcdir server-testsuite

# Clean up.

clean:	
	-rm -f *.o *.sum *.log *~ core
	-for d in Plex Vec Stack Map; do cd $$d; rm *.o *~; cd ..; done
	-rm -f $(PROG) das-test dds-test expr-test error-test geturl \
	       cgi-util-test

distclean: grammarclean
	-rm -f config.status config.log config.cache

# I added this so that distclean will not wipe these files out. Thus people
# without GNU bison/flex (e.g., Dec Alphas which have a scanner generator
# called `flex' which is definately not a recent GNU flex) can still build
# the DAP software. Few people should want to hack these grammar files.

grammarclean: clean
	-rm -f lex.das.c das.tab.c das.tab.h 
	-rm -f lex.dds.c dds.tab.c dds.tab.h
	-rm -f lex.expr.c expr.tab.c expr.tab.h 
	-rm -f lex.Error.c Error.tab.c Error.tab.h

tar:
	cd .. && tar --exclude $(dir)/old --gzip -c -f $(dir).tar.gz $(dir) &&\
		cd $(dir)

tags:
	$(TAGS) $(TAGS_FLAGS) *.cc *.h *.lex *.y

.PHONY: depend
depend: 
	> dependencies
	@depend@ -m dependencies -- $(CPPFLAGS) -I@GPP_INC@ -- \
	$(NETIOSRCS) $(DASSRCS) $(DDSSRCS) $(EXPRSRCS) $(TYPESRCS) \
	$(ERRORSRCS) $(TESTSRCS) $(TESTPROGSRCS)

dds.tab.o: dds.tab.c dds.tab.h DDS.h BaseType.h Byte.h Int32.h Float64.h \
  Str.h Url.h Array.h List.h Structure.h Sequence.h Function.h \
  Grid.h Stack/BTXPStack.h Stack/BTXPlex.h Stack/BTPlex.h Stack/BTdefs.h \
  Stack/BTStack.h 

das.tab.c: DAS.h

.SUFFIXES:      .o .cc .c

.c.o:
	$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<

.cc.o:
	$(CXX) -c $(CXXFLAGS) $(CPPFLAGS) -o $@ $<

include dependencies



